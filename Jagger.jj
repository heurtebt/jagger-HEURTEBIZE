// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)
public class Jagger
{
    public static void main(String args[]) throws ParseException
    {
        Jagger parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|	<STRING: "\""(["a"-"z","A"-"Z","_","0"-"9"])*"\"">		  			  // A string containing any character
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < EOL: "\n" >                             // End of line.
|   < IF: "if" >                              // If.
|   < THEN: "then" >                          // Then.
|   < ELSE: "else" >                          // Else.
|   <PRINT: "print" >                         // Print keyword.
}

// Main lopp: read expressions on a line until end of file.
//     mainloop â†’ (expression <EOL>)* <EOF>
void mainloop():
{ Expression a; }
{
    (
      a=expression() <EOL>
      {
        VisitorPrettyPrinter pp = new VisitorPrettyPrinter();
        VisitorTypeChecker tp = new VisitorTypeChecker();        
        a.accept(pp);
        a.accept(tp);
        if(!tp.hasError()){
			VisitorEvaluator eval = new VisitorEvaluator();
			a.accept(eval);
			System.out.println(pp.prettyPrint()+"=>"+eval.evaluator());
		}else{
			System.out.println("The Type Checker found an error!");
		}
      }
    )*
    <EOF>
}

//

//Expression (Print)
//Ep -> 'print(' Eite ')'|Eite
Expression expression():
{Expression a;}
{
    <PRINT> "(" a=expressionITE() ")" { return new Print(a); }
    | a=expressionITE() { return a; }
}

//Expression (If-Then-Else)*
//Eite -> 'if' Ec 'then' Eite 'else' Eite | Ec
Expression expressionITE():
{Expression a,b,c;}
{
    <IF> a=expressionITE() <THEN> b=expressionITE() <ELSE> c=expressionITE() { return new IfThenElse(a,b,c); }
    | a=expressionComp() { return a; }
}

// Expression (comparison).
// Ec -> E ('='E | '<>'E | '<'E | '>'E | '>='E | '<='E)*
Expression expressionComp():
{ Expression a,b; }
{
    a=expressionAddSub()
    (
      "=" b=expressionComp() { a = new Equal(a,b); }
    | "<>" b=expressionComp() { a = new NotEqual(a,b); }
    | "<" b=expressionComp() { a = new Less(a,b); }
    | ">" b=expressionComp() { a = new More(a,b); }
    | ">=" b=expressionComp() { a = new MoreOrEqual(a,b); }
    | "<=" b=expressionComp() { a = new LessOrEqual(a,b); }
    )? { return a; }
}

// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Expression expressionAddSub():
{ Expression a,b; }
{
    a=term()
    (
      "+" b=expressionAddSub() { a = new Add(a,b); }
    | "-" b=expressionAddSub() { a = new Substract(a,b); }
    )?{ return a; }
}

// Term.
// T -> U ('*'U | '/'U)*
Expression term():
{ Expression a,b; }
{
    a=unary()
    (
      "*" b=factor() { a = new Multiply(a,b); }
    | "/" b=factor() { a = new Divide(a,b); }
    )* { return a; }
}

//Unary.
//U -> ('-'F) | F
Expression unary():
{Expression a;}
{
    "-" a=factor() { return new Negative(a); }
    | a=factor() { return new Positive(a); }
    | a= string(){ return a; }
}

// Factor of an expression.
// F -> <NUMBER> | "(" E ")"
Expression factor():
{ Token t; Expression e; }
{
      t=<NUMBER> { return new Constant(Float.parseFloat(t.toString())); }
    | "(" e=expression() ")" { return e; }
}

//String of an expression
// S -> <STRING>
Expression string():
{ Token t; Expression e; }
{
      
    t=<STRING> { return new ConstantString(t.toString()); }
}

